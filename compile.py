"""Compile/Translate Yahoo Pipe into Python

   (initial proof of concept)

   Takes a JSON representation of a Yahoo pipe and either:
   
     a) translates it into a Python script containing a function (using generators to build the pipeline)
     or
     b) compile it as a pipeline of generators which can be executed in-process
     
   Usage:
     a) python compile.py -f pipe1.json > pipe1.py
        python pipe1.py
        
     b) import compile
        p = compile.parse_and_build_pipe("JSON pipe representation")
        for i in p:
            print i
            
   Instead of passing a filename (-f) a pipe id can be passed (-p) to fetch the JSON from Yahoo.
     
   Author: Greg Gaughan
   Idea: Tony Hirst (http://ouseful.wordpress.com/2010/02/25/starting-to-think-about-a-yahoo-pipes-code-generator)
   Python generator pipelines inspired by: David Beazely (http://www.dabeaz.com/generators-uk)
"""

from optparse import OptionParser
import fileinput
import urllib
import os
import sys

from pipe2py import util

try:
    import json
except ImportError:
    import simplejson as json
   
from topsort import topological_sort

#needed for build_pipe - ensure modules/__init__.py.__all__ lists all available modules
from pipe2py.modules import *


try:
    import wingdbstub
except:
    pass

def _parse_pipe(json_pipe, pipe_name="anonymous"):
    """Parse pipe JSON into internal structures
    
    Keyword arguments:
    json_pipe -- JSON representation of the pipe
    pipe_name -- a name for the pipe (used for linking pipes)
    
    Returns:
    pipe -- an internal representation of a pipe
    """   
    pipe = {'name': util.pythonise(pipe_name)}
    
    pipe['modules'] = {}
    pipe['graph'] = {}
    pipe['wires'] = {}
    for module in json_pipe['modules']:
        pipe['modules'][util.pythonise(module['id'])] = module
        pipe['graph'][util.pythonise(module['id'])] = []

    for wire in json_pipe['wires']:
        pipe['graph'][util.pythonise(wire['src']['moduleid'])].append(util.pythonise(wire['tgt']['moduleid']))

    for wire in json_pipe['wires']:
        pipe['wires'][util.pythonise(wire['id'])] = wire
            
    return pipe

def build_pipe(pipe, verbose=False):
    """Convert a pipe into an executable Python pipeline
    
       Note: any subpipes must be available to import as .py files
    """
    module_sequence = topological_sort(pipe['graph'])

    #First pass to find and import any required subpipelines
    #Note: assumes they have already been compiled to accessible .py files
    for module_id in module_sequence:
        module = pipe['modules'][module_id]
        if module['type'].startswith('pipe:'):
            __import__(util.pythonise(module['type']))
    
    steps = {}
    for module_id in module_sequence:
        module = pipe['modules'][module_id]
        
        #Plumb I/O
        input_module = None
        for wire in pipe['wires']:
            if util.pythonise(pipe['wires'][wire]['tgt']['moduleid']) == module_id and pipe['wires'][wire]['tgt']['id'] == '_INPUT' and pipe['wires'][wire]['src']['id'] == '_OUTPUT':
                input_module = steps[util.pythonise(pipe['wires'][wire]['src']['moduleid'])]
        
        pargs = [input_module]
        kargs = {"conf":module['conf'],
                 "verbose":verbose}
            
        for wire in pipe['wires']:
            if util.pythonise(pipe['wires'][wire]['tgt']['moduleid']) == module_id and pipe['wires'][wire]['tgt']['id'] != '_INPUT' and pipe['wires'][wire]['src']['id'] == '_OUTPUT':
                pargs["%(id)s" % {'id':util.pythonise(pipe['wires'][wire]['tgt']['id'])}] = "%(secondary_module)s" % {'secondary_module':steps[util.pythonise(pipe['wires'][wire]['src']['moduleid'])]}
                
        #todo (re)import other pipes dynamically
        pymodule_name = "pipe%(module_type)s" % {'module_type':module['type']}
        pymodule_generator_name = "pipe_%(module_type)s" % {'module_type':module['type']}
        if module['type'].startswith('pipe:'):
            pymodule_name = "sys.modules['%(module_type)s']" % {'module_type':util.pythonise(module['type'])}
            pymodule_generator_name = "%(module_type)s" % {'module_type':util.pythonise(module['type'])}            
                
        module_ref = eval("%(pymodule_name)s.%(pymodule_generator_name)s" % {'pymodule_name':pymodule_name, 
                                                                             'pymodule_generator_name':pymodule_generator_name,})
        steps[module_id] = module_ref(*pargs, **kargs)

        if verbose:
            print "%s (%s) = %s(%s)" %(steps[module_id], module_id, module_ref, str(pargs))

    return steps[module_id]
    
    
def write_pipe(pipe, verbose=False):
    """Convert a pipe into Python script
    """

    pypipe = ("""#Pipe %(pipename)s generated by pipe2py\n"""
              """\n"""
              """from pipe2py.modules import *\n"""
              """\n""" % {'pipename':pipe['name']}
             )
    
    module_sequence = topological_sort(pipe['graph'])
    
    #First pass to find any required subpipelines
    for module_id in module_sequence:
        module = pipe['modules'][module_id]
        if module['type'].startswith('pipe:'):
            pypipe += """import %(module_type)s\n""" % {'module_type':util.pythonise(module['type'])}
    
    pypipe += ("""\n"""
               """def %(pipename)s(_INPUT, conf=None, verbose=False, **kwargs):\n"""
               """    "Pipeline"\n"""     #todo insert pipeline description here
               """\n""" % {'pipename':pipe['name']}
              )

    for module_id in module_sequence:
        module = pipe['modules'][module_id]

        #Plumb I/O
        input_module = None
        for wire in pipe['wires']:
            if util.pythonise(pipe['wires'][wire]['tgt']['moduleid']) == module_id and pipe['wires'][wire]['tgt']['id'] == '_INPUT' and pipe['wires'][wire]['src']['id'] == '_OUTPUT':
                input_module = util.pythonise(pipe['wires'][wire]['src']['moduleid'])
        
        pargs = ["%(input_module)s" % {'input_module':input_module}, 
                 "conf=%(conf)s" % {'conf':module['conf']},
                 "verbose=%(verbose)s" % {'verbose':verbose}]
        
        for wire in pipe['wires']:
            if util.pythonise(pipe['wires'][wire]['tgt']['moduleid']) == module_id and pipe['wires'][wire]['tgt']['id'] != '_INPUT' and pipe['wires'][wire]['src']['id'] == '_OUTPUT':
                pargs.append("%(id)s = %(secondary_module)s" % {'id':util.pythonise(pipe['wires'][wire]['tgt']['id']), 'secondary_module':util.pythonise(pipe['wires'][wire]['src']['moduleid'])})
        
        pymodule_name = "pipe%(module_type)s" % {'module_type':module['type']}
        pymodule_generator_name = "pipe_%(module_type)s" % {'module_type':module['type']}
        if module['type'].startswith('pipe:'):
            pymodule_name = "%(module_type)s" % {'module_type':util.pythonise(module['type'])}
            pymodule_generator_name = "%(module_type)s" % {'module_type':util.pythonise(module['type'])}            
                
        pypipe += """    %(module_id)s = %(pymodule_name)s.%(pymodule_generator_name)s(%(pargs)s)\n""" % {'module_id':module_id, 
                                                                                                          'pymodule_name':pymodule_name, 
                                                                                                          'pymodule_generator_name':pymodule_generator_name, 
                                                                                                          'pargs':", ".join(pargs)}
        prev_module = module_id
    
    pypipe += """    return _OUTPUT\n"""
    pypipe += ("""\n"""
               """if __name__ == "__main__":\n"""
               """    p = %(pipename)s(None)\n"""
               """    for i in p:\n"""
               """        print i\n""" % {'pipename':pipe['name']}
              )
        
    return pypipe

def parse_and_write_pipe(json_pipe, pipe_name="anonymous", verbose=False):
    pipe = _parse_pipe(json_pipe, pipe_name)
    pw = write_pipe(pipe, verbose)
    return pw

def parse_and_build_pipe(json_pipe, verbose=False):
    pipe = _parse_pipe(json_pipe, "anonymous")
    pb = build_pipe(pipe, verbose)   
    return pb

if __name__ == '__main__':  
    pjson = []
    
    parser = OptionParser()
    parser.add_option("-f", "--file", dest="filename",
                      help="read pipe JSON from FILE", metavar="FILE")    
    parser.add_option("-p", "--pipe", dest="pipeid",
                      help="read pipe JSON from Yahoo", metavar="PIPEID")   
    parser.add_option("-s", dest="savejson",
                      help="save pipe JSON to file", action="store_true")    
    parser.add_option("-v", dest="verbose",
                      help="set verbose debug", action="store_true")    
    (options, args) = parser.parse_args()
    
    name = "anonymous"
    if options.pipeid:
        url = ("""http://query.yahooapis.com/v1/public/yql"""
               """?q=select%20PIPE.working%20from%20json%20"""
               """where%20url%3D%22http%3A%2F%2Fpipes.yahoo.com%2Fpipes%2Fpipe.info%3F_out%3Djson%26_id%3D"""
               + options.pipeid + 
               """%22&format=json""")
        pjson = urllib.urlopen(url).readlines()
        pjson = "".join(pjson)
        pipe_def = json.loads(pjson)
        if not pipe_def['query']['results']:
            print "Pipe not found"
            sys.exit(1)
        pjson = json.dumps(pipe_def['query']['results']['json']['PIPE']['working'])
        pipe_def = pipe_def['query']['results']['json']['PIPE']['working']
        name = "pipe_%s" % options.pipeid
    elif options.filename:
        for line in fileinput.input(options.filename):
            pjson.append(line)    
        pjson = "".join(pjson)
        pipe_def = json.loads(pjson)
        name = os.path.splitext(os.path.split(options.filename)[-1])[0]
    else:
        for line in fileinput.input():
            pjson.append(line)    
        pjson = "".join(pjson)
        pipe_def = json.loads(pjson)
        
    if options.savejson:
        fj = open("%s.json" % name, "w")   #todo confirm file overwrite
        print >>fj, pjson
        
    
    fp = open("%s.py" % name, "w")   #todo confirm file overwrite
    print >>fp, parse_and_write_pipe(pipe_def, name)
    
    #for build example - see test/testbasics.py
